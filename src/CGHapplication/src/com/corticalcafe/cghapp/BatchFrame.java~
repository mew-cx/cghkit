/*
 *
 * The CorticalCafe Computer Generated Hologram (CGH) Construction Kit
 * (C)2010 Alan Stein
 * www.corticalcafe.com
 *
 * Code released under the GPL v3.
 * http://www.gnu.org/licenses/gpl.html
 *
 * Software freedom is about:
 *    - the freedom to use software for any purpose,
 *    - the freedom to change software to suit your needs,
 *    - the freedom to share software with your friends and neighbors, and
 *    - the freedom to share the changes you make.
 *
 * Take the time to learn about and support free software.
 * If you don't, who will?
 *
 */

package com.corticalcafe.cghapp;

import com.corticalcafe.primitives.DebugMessages;
import com.corticalcafe.primitives.physics.PointSource;
import com.corticalcafe.primitives.physics.PointSourceArray;
import com.corticalcafe.utils.FTPsync;
import com.corticalcafe.utils.SimpleFileLock;
import com.corticalcafe.utils.MiscUtils;
import java.awt.Color;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;


/**
 *
 * @author astein
 */
public class BatchFrame extends javax.swing.JFrame {

    static Simulation simulation=new Simulation();
    static File curFile;
    static boolean batchProcessing=false;
    boolean curFileProcessing=false;
    boolean centerObject;
    boolean centerPlate;
    boolean scaleObject;
    boolean multiThread;

    public void setMultiThread(boolean multiThread) {
        this.multiThread = multiThread;
    }


    /** Creates new form BatchFrame */
    public BatchFrame() {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextAreaBatchJobs = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jTextFieldUptime = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jTextFieldQueuedJobs = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        jTextFieldCurrentJob = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jTextFieldTotalJobs = new javax.swing.JTextField();
        jTextFieldFTPstatus = new javax.swing.JTextField();
        jTextFieldBatchStatus = new javax.swing.JTextField();
        jButtonFTPsync = new javax.swing.JButton();
        jButtonBatchProc = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        jTextFieldFTPfrequency = new javax.swing.JTextField();
        jPanel2 = new javax.swing.JPanel();
        jProgressBarStatus = new javax.swing.JProgressBar();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenu2 = new javax.swing.JMenu();
        jMenuItemStartBatch = new javax.swing.JMenuItem();
        jMenuItemToggleFTPsync = new javax.swing.JMenuItem();
        jCheckBoxMenuItemSimulateFTP = new javax.swing.JCheckBoxMenuItem();
        jCheckBoxMenuItemDoComputations = new javax.swing.JCheckBoxMenuItem();

        setName("Form"); // NOI18N
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowOpened(java.awt.event.WindowEvent evt) {
                formWindowOpened(evt);
            }
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jPanel1.setName("jPanel1"); // NOI18N

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        jScrollPane1.setName("jScrollPane1"); // NOI18N

        jTextAreaBatchJobs.setColumns(20);
        jTextAreaBatchJobs.setRows(5);
        jTextAreaBatchJobs.setName("jTextAreaBatchJobs"); // NOI18N
        jScrollPane1.setViewportView(jTextAreaBatchJobs);

        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(com.corticalcafe.cghapp.CGHapplication.class).getContext().getResourceMap(BatchFrame.class);
        jLabel1.setText(resourceMap.getString("jLabel1.text")); // NOI18N
        jLabel1.setName("jLabel1"); // NOI18N

        jTextFieldUptime.setText(resourceMap.getString("jTextFieldUptime.text")); // NOI18N
        jTextFieldUptime.setName("jTextFieldUptime"); // NOI18N

        jLabel2.setText(resourceMap.getString("jLabel2.text")); // NOI18N
        jLabel2.setName("jLabel2"); // NOI18N

        jTextFieldQueuedJobs.setText(resourceMap.getString("jTextFieldQueuedJobs.text")); // NOI18N
        jTextFieldQueuedJobs.setName("jTextFieldQueuedJobs"); // NOI18N

        jLabel3.setText(resourceMap.getString("jLabel3.text")); // NOI18N
        jLabel3.setName("jLabel3"); // NOI18N

        jTextFieldCurrentJob.setText(resourceMap.getString("jTextFieldCurrentJob.text")); // NOI18N
        jTextFieldCurrentJob.setName("jTextFieldCurrentJob"); // NOI18N

        jLabel4.setText(resourceMap.getString("jLabel4.text")); // NOI18N
        jLabel4.setName("jLabel4"); // NOI18N

        jTextFieldTotalJobs.setText(resourceMap.getString("jTextFieldTotalJobs.text")); // NOI18N
        jTextFieldTotalJobs.setName("jTextFieldTotalJobs"); // NOI18N

        jTextFieldFTPstatus.setBackground(resourceMap.getColor("jTextFieldFTPstatus.background")); // NOI18N
        jTextFieldFTPstatus.setText(resourceMap.getString("jTextFieldFTPstatus.text")); // NOI18N
        jTextFieldFTPstatus.setName("jTextFieldFTPstatus"); // NOI18N

        jTextFieldBatchStatus.setBackground(resourceMap.getColor("jTextFieldBatchStatus.background")); // NOI18N
        jTextFieldBatchStatus.setText(resourceMap.getString("jTextFieldBatchStatus.text")); // NOI18N
        jTextFieldBatchStatus.setName("jTextFieldBatchStatus"); // NOI18N

        jButtonFTPsync.setText(resourceMap.getString("jButtonFTPsync.text")); // NOI18N
        jButtonFTPsync.setName("jButtonFTPsync"); // NOI18N
        jButtonFTPsync.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonFTPsyncActionPerformed(evt);
            }
        });

        jButtonBatchProc.setText(resourceMap.getString("jButtonBatchProc.text")); // NOI18N
        jButtonBatchProc.setName("jButtonBatchProc"); // NOI18N
        jButtonBatchProc.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonBatchProcActionPerformed(evt);
            }
        });

        jLabel5.setText(resourceMap.getString("jLabel5.text")); // NOI18N
        jLabel5.setName("jLabel5"); // NOI18N

        jTextFieldFTPfrequency.setText(resourceMap.getString("jTextFieldFTPfrequency.text")); // NOI18N
        jTextFieldFTPfrequency.setName("jTextFieldFTPfrequency"); // NOI18N
        jTextFieldFTPfrequency.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextFieldFTPfrequencyActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 152, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel2)
                            .addComponent(jLabel1)
                            .addComponent(jLabel4))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jTextFieldTotalJobs, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE)
                            .addComponent(jTextFieldQueuedJobs, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE)
                            .addComponent(jTextFieldUptime, javax.swing.GroupLayout.DEFAULT_SIZE, 150, Short.MAX_VALUE)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldCurrentJob, javax.swing.GroupLayout.DEFAULT_SIZE, 188, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(jButtonFTPsync, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jButtonBatchProc, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addComponent(jLabel5))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jTextFieldFTPfrequency)
                            .addComponent(jTextFieldBatchStatus)
                            .addComponent(jTextFieldFTPstatus, javax.swing.GroupLayout.DEFAULT_SIZE, 91, Short.MAX_VALUE))))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 238, Short.MAX_VALUE)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldUptime, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldQueuedJobs, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldTotalJobs, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jTextFieldCurrentJob, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldFTPstatus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonFTPsync))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldBatchStatus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonBatchProc))
                .addGap(11, 11, 11)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldFTPfrequency, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel5))
                .addContainerGap())
        );

        jPanel2.setName("jPanel2"); // NOI18N

        jProgressBarStatus.setName("jProgressBarStatus"); // NOI18N

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jProgressBarStatus, javax.swing.GroupLayout.DEFAULT_SIZE, 412, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jProgressBarStatus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        jMenuBar1.setDoubleBuffered(true);
        jMenuBar1.setName("jMenuBar1"); // NOI18N

        jMenu1.setText(resourceMap.getString("jMenu1.text")); // NOI18N
        jMenu1.setName("jMenu1"); // NOI18N
        jMenuBar1.add(jMenu1);

        jMenu2.setText(resourceMap.getString("jMenu2.text")); // NOI18N
        jMenu2.setName("jMenu2"); // NOI18N

        jMenuItemStartBatch.setText(resourceMap.getString("jMenuItemStartBatch.text")); // NOI18N
        jMenuItemStartBatch.setName("jMenuItemStartBatch"); // NOI18N
        jMenuItemStartBatch.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemStartBatchActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItemStartBatch);

        jMenuItemToggleFTPsync.setText(resourceMap.getString("jMenuItemToggleFTPsync.text")); // NOI18N
        jMenuItemToggleFTPsync.setName("jMenuItemToggleFTPsync"); // NOI18N
        jMenuItemToggleFTPsync.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemToggleFTPsyncActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItemToggleFTPsync);

        jCheckBoxMenuItemSimulateFTP.setText(resourceMap.getString("jCheckBoxMenuItemSimulateFTP.text")); // NOI18N
        jCheckBoxMenuItemSimulateFTP.setName("jCheckBoxMenuItemSimulateFTP"); // NOI18N
        jMenu2.add(jCheckBoxMenuItemSimulateFTP);

        jCheckBoxMenuItemDoComputations.setSelected(true);
        jCheckBoxMenuItemDoComputations.setText(resourceMap.getString("jCheckBoxMenuItemDoComputations.text")); // NOI18N
        jCheckBoxMenuItemDoComputations.setName("jCheckBoxMenuItemDoComputations"); // NOI18N
        jMenu2.add(jCheckBoxMenuItemDoComputations);

        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents



    private void jMenuItemStartBatchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemStartBatchActionPerformed
        if(getBatchProcessing())
        {
            stopProcessing();
        }
        else
        {
            startProcessing();
        }
    }//GEN-LAST:event_jMenuItemStartBatchActionPerformed


    FTPsync ftpSync=new FTPsync();

    private void jMenuItemToggleFTPsyncActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemToggleFTPsyncActionPerformed
        if(!ftpSync.isFTPrunning())
        {
            startFTPsync();
        }
        else
        {
            stopFTPsync();
        }
    }//GEN-LAST:event_jMenuItemToggleFTPsyncActionPerformed

    private void jButtonFTPsyncActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonFTPsyncActionPerformed
        if(!ftpSync.isFTPrunning())
        {
            startFTPsync();
        }
        else
        {
            stopFTPsync();
        }
    }//GEN-LAST:event_jButtonFTPsyncActionPerformed

    private void jButtonBatchProcActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonBatchProcActionPerformed
        if(getBatchProcessing())
        {
            stopProcessing();
        }
        else
        {
            startProcessing();
        }
    }//GEN-LAST:event_jButtonBatchProcActionPerformed


    private void jTextFieldFTPfrequencyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextFieldFTPfrequencyActionPerformed
        ftpSync.setFtpFreqSec(Integer.valueOf(jTextFieldFTPfrequency.getText()));
    }//GEN-LAST:event_jTextFieldFTPfrequencyActionPerformed


    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        if(getBatchProcessing())
        {
            stopProcessing();
        }

        if(ftpSync.isFTPrunning())
        {
           stopFTPsync();
        }

    }//GEN-LAST:event_formWindowClosing

    private void formWindowOpened(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened
        jTextFieldFTPfrequency.setText(String.valueOf(FTPsync.FTPFREQ_DEFAULT));
    }//GEN-LAST:event_formWindowOpened


   
    public void startFTPsync()
    {
        ftpSync.setFtpSite("myftpsite.com");
        ftpSync.setFtpUsername("user@myftpsite.com", "password");
        ftpSync.setLocalDir(fileDir.getPath());

        ftpSync.setSimulate(jCheckBoxMenuItemSimulateFTP.isSelected());
        ftpSync.start();
        jTextFieldFTPstatus.setText("Running");
        jTextFieldFTPstatus.setBackground(Color.GREEN);
        jMenuItemToggleFTPsync.setText("Stop FTP Sync");
    }


    public void stopFTPsync()
    {
        ftpSync.stop();
        ftpSync.syncHologramFTPdirectory();
        jTextFieldFTPstatus.setText("Stopped");
        jTextFieldFTPstatus.setBackground(Color.RED);
        jMenuItemToggleFTPsync.setText("Start FTP Sync");
    }




    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new BatchFrame().setVisible(true);
            }
        });
    }

    File batchFiles[];
    File fileDir;

    public void setBatchFileDir(File file)
    {
        fileDir=file;
//        DebugMessages.inform("FileDir="+fileDir);
    }



    long startTime = System.currentTimeMillis();

    void updateTime()
    {
        double runTime=System.currentTimeMillis()-startTime;

        runTime=runTime/1000;

        jTextFieldUptime.setText(getElapsedTimeString(startTime));

    }


public static String getElapsedTimeString(long startTime) {
    long duration = System.currentTimeMillis() - startTime;
    long seconds = TimeUnit.MILLISECONDS.toSeconds(duration);
    long days = TimeUnit.MILLISECONDS.toDays(duration);
    long hours = TimeUnit.MILLISECONDS.toHours(duration);
    long minutes = TimeUnit.MILLISECONDS.toMinutes(duration);
    
    if (days > 0) {
        return days + "d ";
    }
    if (hours > 0) {
        return hours + "h ";
    }
    if (minutes > 0) {
        return minutes + "m ";
    }

    return seconds + "s";
}




    void populateList()
    {
            populateListFromLocalDirectory();
    }

    public void setCenterObject(boolean centerObject) {
        this.centerObject = centerObject;
    }

    public void setCenterPlate(boolean centerPlate) {
        this.centerPlate = centerPlate;
    }

    public void setScaleObject(boolean scaleObject) {
        this.scaleObject = scaleObject;
    }



    void populateListFromLocalDirectory()
    {
        batchFiles=new File(fileDir.toString()).listFiles();

//        batchFiles=fileDir.listFiles();
        batchFiles=cleanBatchList(batchFiles);

        jTextAreaBatchJobs.setText("");
        for (int i = 0; i < batchFiles.length; i++)
        {
            jTextAreaBatchJobs.setText(jTextAreaBatchJobs.getText()
                    +batchFiles[i].getName()+"\n");
        }

        jTextFieldQueuedJobs.setText(String.valueOf(batchFiles.length));
    }


    File[] cleanBatchList(File batchList[])
    {
        int numFiles=batchList.length;
        File retFile[];

        //if the filename is a directory, has an output file, or starts with "." then remove it
        for (int i = 0; i < batchList.length; i++)
        {
            if (batchList[i].isDirectory() 
                    || batchList[i].getName().endsWith("_output.gif")
                    || batchList[i].getName().startsWith("."))
            {
                batchList[i]=null;
                numFiles--;
            }
            else    //or if it is an input file but has already been calculated (has matching outout file)
            if (new File(fileDir+"/"+getHoloFileName(batchList[i].getName())).exists())
            {
                batchList[i]=null;
                numFiles--;
            }
            else    //remove locked files
            {
                SimpleFileLock sfl=new SimpleFileLock(batchList[i]);
                if(sfl.getLock()==false)    //try to get lock
                {
                    batchList[i]=null;      //if can't, then remove file
                    numFiles--;
                }
                else
                    sfl.unlock();           //unlock (if we were able to get the lock!)
            }

        }

        retFile=new File[numFiles];

//        DebugMessages.inform("CleanBL:  In="+batchList.length+" out="+retFile.length);
        
        int j=0;
        for (int i = 0; i < batchList.length; i++) {
            if (batchList[i]!=null)
            {
                retFile[j]=batchList[i];
                j++;
            }
        }

//        debugFiles("Before", batchList);
//        debugFiles("After", retFile);


        return retFile;
    }


    void processFile(final File curFile)
    {
        if(curFileProcessing){
            DebugMessages.error("File already processing...");
        }
        else
        {
            curFileProcessing=true;

            simulation=new Simulation();

            DebugMessages.inform("Starting simulation");
            updateStatus("Starting Simulation");
            simulation.setRandomPhase(true);
            simulation.setMultithread(multiThread);

            simulation.setPriority(1);

            int xRes=600;
            int yRes=600;
            double xPlateSampling=423e-7;
            double yPlateSampling=423e-7;


            //dummy PSA used because first time run has instantiation issue to be debugged
            PointSourceArray dummyPSA=new PointSourceArray();
            dummyPSA.addPointSource(new PointSource(0.0150, 0.0150, 4, 1, 670e-9, -1.25));
            simulation.setObject(dummyPSA);
            simulation.addNewPlate(xRes, yRes, xPlateSampling, yPlateSampling); //init object and plate

            simulation.getPlate().debug("Plate: ");

            PointSourceArray objectPSA=new PointSourceArray();
            double objectSampling;
            objectSampling=6768e-7; //user defined opject sampling

            double imageDepth=2;
            double imageWavelength=600e-9;
            

//            DebugMessages.inform("Processing:  "+curFile.getName());

            jTextFieldCurrentJob.setText(curFile.getName());

            try
            {
                objectPSA.loadPointSourceArrayFromFile(curFile, 0, 0, imageDepth,
                      objectSampling, imageWavelength);


                objectPSA.debugSummary("Original Object");


            //scales the object to the same size as the plate
            if(scaleObject && objectPSA.getNumberOfPoints()>1)  //scale object to same size as plate
            {
                objectPSA.scaleXYtoPlate(simulation.getPlate());
                objectPSA.debugSummary("Scaled Object");
            }


            //center the object WRT the XY origin (should be used w/ center plate)
            if(centerObject)
            {
                objectPSA.centerObjectXY();
                objectPSA.debugSummary("Centered Object");
            }


            if(centerPlate || centerObject)
            {
            //apply XY offset (if any) to object, also used to center plate
                objectPSA.shiftXYZ((simulation.getPlate().getXresolution()/2.0)*xPlateSampling,
                    (simulation.getPlate().getYresolution()/2.0)*yPlateSampling, 0);

                objectPSA.debugSummary("Shifted Object");
            }


//                  DebugMessages.inform("Setting simulation pointsource object");
                  simulation.setObject(objectPSA);
                  simulation.initializeSimulation();
                  updateStatus("Simulating");

                  DebugMessages.inform("Simulating");
                  simulation.startSimulation(); //start simulation thread


                    class UpdateSimInfo extends Thread
                    {
                        UpdateSimInfo() {
                        }

                        @Override public void run() {
                            jProgressBarStatus.setIndeterminate(false);
                            do
                            {
                              try
                              {
                                Thread.sleep(250);
                              }
                              catch (InterruptedException ex)
                              {
                                ex.printStackTrace();
                              }

                              updateStatus(simulation.getStatus());
                              jProgressBarStatus.setValue((int)simulation.getPercentComplete());
                            }while(simulation.isSimulationRunning());

                            if(getBatchProcessing())
                            {
                                RealPhotoPlate of=new RealPhotoPlate(simulation.getPlate());

        //                        simulation.getPlate().debug("Batch:  ");

                                of.computeOutputImage(RealPhotoPlate.OUTPUT_REAL_BINARY,
                                        true, false, 127);

                                String fileName;
                                fileName=curFile.getAbsolutePath();

                                fileName=getHoloFileName(fileName);

                                File file=new File(fileName);


                                SimpleFileLock sfl=new SimpleFileLock(file);

                                if(sfl.getLock())
                                {
                                    DebugMessages.inform("Saving: "+file.getAbsolutePath());
                                    updateStatus("Saving");

                                    of.saveAsGIF(file);

                                    sfl.unlock();
                                }

                                int curTot=Integer.valueOf(jTextFieldTotalJobs.getText());
                                curTot++;
                                jTextFieldTotalJobs.setText(String.valueOf(curTot));

                            }

                            curFileProcessing=false;

                        }
                    }

                  UpdateSimInfo usim=new UpdateSimInfo();
                  usim.start();    //start thread to update status bar with thread progress each second, and to generate simulation output


            }
            catch (Exception e)
            {
                DebugMessages.error("Failed to read object!");
                updateStatus("Failed to read object!");
                
                String fileName;
                fileName=curFile.getAbsolutePath();

                fileName=getHoloFileName(fileName);

                File file=new File(fileName);

                DebugMessages.inform("Saving failed hologram: "+file.getAbsolutePath());
                try {
                    file.createNewFile();
                } catch (IOException ex) {
                    Logger.getLogger(BatchFrame.class.getName()).log(Level.SEVERE, null, ex);
                }

                curFileProcessing=false;

            }


        }

    }



    void updateStatusFile(String statusStr)
    {
        String fileName;

        fileName=fileDir+"/.status";
        File statusFile=new File(fileName);

        FileOutputStream fop = null;

        statusStr=statusStr+"\n";

//        statusStr=statusStr+"Batch Length:  "+String.valueOf(batchFiles.length)+"\n";

        final String DATE_FORMAT_NOW = "yyyy-MM-dd HH:mm:ss";

        Calendar cal = Calendar.getInstance();
        SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT_NOW);
        statusStr+="Last update:  "+sdf.format(cal.getTime())+" EST\n";

        try
        {
            fop = new FileOutputStream(statusFile);
            fop.write(statusStr.getBytes());;
            fop.flush();
            fop.close();
        } catch (IOException ex) {
            Logger.getLogger(BatchFrame.class.getName()).log(Level.SEVERE, null, ex);
        }

    }


    void monitorBatch()
    {
        class MonitorBatchList extends Thread
        {
            MonitorBatchList()
            {
            }

            @Override public void run()
            {
                jProgressBarStatus.setIndeterminate(false);
                do
                {
                    populateList();
                    updateTime();

                    if(batchFiles.length>0 && jCheckBoxMenuItemDoComputations.isSelected()
                            && !curFileProcessing)
                        processFile(batchFiles[0]);
                    else if(batchFiles.length==0)
                    {
                        updateStatus("Idle");
                        jTextFieldCurrentJob.setText("");
                    }

                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException ex) {
                        Logger.getLogger(BatchFrame.class.getName()).log(Level.SEVERE, null, ex);
                    }
                } while (getBatchProcessing());

                updateStatus("Stopped");

            }
        }

        MonitorBatchList mbl=new MonitorBatchList();
        mbl.start();

    }


    void monitorStatusFile()
    {
        class MonitorStatusFile extends Thread
        {
            MonitorStatusFile()
            {
            }

            @Override public void run()
            {
                jProgressBarStatus.setIndeterminate(false);
                do
                {
                    updateStatusFile("Online and Processing!");

                    try {
                        Thread.sleep(60*1000);
                    } catch (InterruptedException ex) {
                        Logger.getLogger(BatchFrame.class.getName()).log(Level.SEVERE, null, ex);
                    }
                } while (getBatchProcessing());

            }
        }

        MonitorStatusFile msf=new MonitorStatusFile();
        msf.start();

    }



    boolean getBatchProcessing()
    {
        return batchProcessing;
    }


    void setBatchProcessing(boolean flag)
    {
        batchProcessing=flag;
    }


    public void startProcessing()
    {
        setBatchProcessing(true);
        monitorBatch();
        monitorStatusFile();
        jMenuItemStartBatch.setText("Stop Batch Processing");
        jTextFieldBatchStatus.setText("Running");
        jTextFieldBatchStatus.setBackground(Color.GREEN);

    }

    public void stopProcessing()
    {
        setBatchProcessing(false);
        simulation.stopSimulation();
        jMenuItemStartBatch.setText("Start Batch Processing");
        jTextFieldBatchStatus.setText("Stopped");
        jTextFieldBatchStatus.setBackground(Color.RED);
        updateStatusFile("Offline.  Not Processing.");
    }


    void debugFiles(String str, File f[])
    {
        DebugMessages.inform(str);
        for (int i = 0; i < f.length; i++)
        {
            if(f[i]==null)
            {
                DebugMessages.inform("File["+i+"]:  *NULL*");
            }
            else
            if (f[i].isFile()) {
                DebugMessages.inform("File["+i+"]: "+f[i].getName());
            }
            else
            {
                DebugMessages.inform("File["+i+"]:  *DIRECTORY*");
            }
            
        }
    }


    String getHoloFileName(String file)
    {
        return MiscUtils.removeExtension(file)+"_output.gif";
    }


    void updateStatus(String str)
    {
        jProgressBarStatus.setString(str);
        jProgressBarStatus.setStringPainted(true);
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonBatchProc;
    private javax.swing.JButton jButtonFTPsync;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemDoComputations;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemSimulateFTP;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItemStartBatch;
    private javax.swing.JMenuItem jMenuItemToggleFTPsync;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JProgressBar jProgressBarStatus;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextAreaBatchJobs;
    private javax.swing.JTextField jTextFieldBatchStatus;
    private javax.swing.JTextField jTextFieldCurrentJob;
    private javax.swing.JTextField jTextFieldFTPfrequency;
    private javax.swing.JTextField jTextFieldFTPstatus;
    private javax.swing.JTextField jTextFieldQueuedJobs;
    private javax.swing.JTextField jTextFieldTotalJobs;
    private javax.swing.JTextField jTextFieldUptime;
    // End of variables declaration//GEN-END:variables

}
